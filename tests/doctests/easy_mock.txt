This file includes
* extended doctests of the easy_mock() and mock() functions, and
* the resulting short introduction to using these functions.

Introduction
------------

The checkit.testing functions are directly downloaded from the base checkit
module:

>>> from checkit import easy_mock, mock

The easy_mock() function offers the main functionality, that is, to create
a mock object of either a function or another non-class object. (For the
moment, the checkit module does not offer mocking of classes.) The mock()
function is a simple wrapper that offers you an additional functionality
of keeping the original object, which you can then use (which is a rare
situation).

Such mocking is intended to be used during testing, particularly in doctesting.
The unittest module offers much more advanced mocking functions, but - as its
name suggest - easy_mock() offers simplicity. Consider the following fragment
of code:

>>> def read_from_data_base():
...    # imagine the function needs 10 seconds to download the data from DB
...    import time
...    time.sleep(5)
...    # this is what these data would like like
...    something, success, data = 50, True, range(1000)
...    return something, success, data

It would be good, of course, to test this function, but this will take 10 sec.
It's OK, but if you have to use these data in other doctests, then you're in
trouble, since doctests are isolated. So, instead of using this function in
every single doctest you need the data, you can create a mock of it, like here:

>>> def read_from_data_base():
...    return 50, True, range(10)

There is one big problem with this: poor readability. The reader does not have
to know that there is such a function, read_from_data_base(), which you are
mocking because it takes too much time. This is where easy_mock() can help:

>>> read_from_data_base = easy_mock(read_from_data_base, (50, True, range(10)))

Now the reader will know that you are creating a mock object. It will return
so example data that you will be able to use in testing.

>>> def analyze_data(data):
...    return sum(data)
>>> something, success, data = read_from_data_base()
>>> something
50
>>> success
True
>>> len(data)
10


Another example
---------------

Imagine you have a function that uses command-line arguments. Surely, you do
not want to test this function using arguments from the shell! You can easily
use easy_mock() for this, like below. First, let us define the function:

>>> import sys
>>> def foo():
...    alpha, beta = sys.argv[1:3]
...    return alpha**2/(beta + 1)

Now, in your test, you cannot just run foo(), because you will get
>>> foo()
Traceback (most recent call last):
    ...
ValueError: not enough values to unpack (expected 2, got 1)

So, instead, let's first mock the arguments:
>>> sys.argv = [None, 10, 20]
>>> x = foo()
>>> round(x, 2)
4.76

So, as you see, easy_mock() works globally - since we assigned 
sys.argv = [None, 10, 20] in the global environment and it was reachable in
the local environment of foo(). However, it does only in the isolated
environment of the particular doctest. So, in the next doctest, sys.argv will
again have to be mocked.

Note that you can use any arguments in the mocked object, even when its
original did not have any:
>>> def foo():
...    return 500
>>> foo(20)
Traceback (most recent call last):
    ...
TypeError: foo() takes 0 positional arguments but 1 was given
>>> foo = easy_mock(foo, returns=100)
>>> foo(20, 50, whatever='whatever')
100

This is of course not that helpful in this particular scenario, but it is when
you want to mock a function with many arguments, as we will see in the next
example.


Yet another example
-------------------

>>> def build_bootstraped_model(
...    y,
...    historical_data,
...    external_regressors,
...    model_specs,
...    options,
...    alpha,
...    confidence_level):
...    # do whatever the model requires
...    the_model = 0, 0, 0, 0
...    return the_model

Of course, above the model will never be a tuple of zeros, but will be a
complex object with many elements, depending on bootstraping and the seed.
Sure, if we want to test many other functions that use such a model, we can set
the seed and use the function to build an example model. But we can also mock
it instead of bulding it, which would require us to take care of all these
arguments, rather a burden when writing a doctest.

>>> (y,
...  historical_data,
...  external_regressors,
...  models_specs,
...  options,
...  alpha,
...  confidence_level) = [easy_mock(None, None)]*7

Note that here we could do the same with just None instead of
easy_mock(None, None), but again, it's about readability of the doctest: we're
saying that way that these are things that should be taken from somewhere,
like being made available by previous parts of the code. Now we let's mock
the function:

>>> build_bootstraped_model = easy_mock(build_bootstraped_model,
...    returns=(0, 1.2, .0034, 0.12))
>>> boot_model = build_bootstraped_model(
...    y, historical_data, external_regressors,
...    model_specs, options, alpha, confidence_level)
>>> boot_model2 = build_bootstraped_model(
...    1, 2, 3, 4, 5, 6, 7)
>>> print(boot_model)
(0, 1.2, 0.0034, 0.12)
>>> assert boot_model == boot_model2

A mock() example
----------------

While easy_mock() offers simplicity, it does not offer a possibility to return
to the original functionality of the mocked function. mock() is a simple
wrapped to offer this. It works like this:

>>> def foo():
...    return 5
>>> foo()
5
>>> original_foo, foo = mock(foo, returns=10)
>>> foo()
10
>>> foo = original_foo
>>> foo()
5

There is nothing particularly complex behind this functionality, and you could
achieve the same in various other way, like
>>> original_foo, foo = foo, easy_mock(foo, returns=10)
>>> foo()
10
>>> foo = original_foo
>>> foo()
5

but we think that the above version is slightly more readable.